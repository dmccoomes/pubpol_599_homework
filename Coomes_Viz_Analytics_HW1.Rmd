<br> 
<center><img src="http://i.imgur.com/sSaOozN.png" width="500"></center>

## Course: Visual Analytics for Policy and Management

### David Coomes, Homework 1

_____
<a id='part1'></a

```{r getData, eval=TRUE}
link='https://github.com/EvansDataScience/VisualAnalytics_2_tabularData/raw/master/data/eduwa.rda'

#getting the data TABLE from the file in the cloud:
load(file=url(link))
```



```{r freqTab_abs, include=FALSE}
# absolute values
table(eduwa$LocaleType,exclude = 'nothing')
```

```{r freqTab_rel, include=FALSE}
# relative values
absoluteT=table(eduwa$LocaleType,exclude = 'nothing')
prop.table(absoluteT)
```

This table tells us the location of the public schools. What is the right visual for this? Sometimes the answer seems obvious, as tradition or habits give so much weight to decisions. Let's use the very well known **pie chart**:

```{r pieBasic, include=FALSE}
# the pie plots the table:
ToPlot=prop.table(absoluteT)

```

You should always keep it simple. Then decorate. For example, you can start improving the plot you already *have*:

* The purple sector does not show a label:

```{r namesFre_NA, include=FALSE}
names(ToPlot)
```

We could alter the fifth label:
```{r alterTable, include=FALSE}
names(ToPlot)[5]='Unknown'
```


* Our plot did not have a title. Titles (and subtitles) are important. To give a title, it can be a *question* to be answered by the plot:


```{r pieTitle_question, include=FALSE}
# the pie plots the table:
titleText='Where are Public Schools located in WA in 2019?'
sourceText='Source: US Department of Education'

```

The title can *guide* the reader to recognise the purpose of your plot:

```{r pieTitle_guide, include=FALSE}
# the pie plots the table:
titleText2='WA still has schools locations unknown \n (info from 2018)'

```


The title can also *suggest* the decision:

```{r pieTitle_suggestion, include=FALSE}
# the pie plots the table:
titleText3='WA needs to fully categorize school locations\n(info from 2018)'

#DMC - the \n moves the rest of the title to the next line

```

* You can use the values as labels. If values between [0,1]  represent shares, it is better to use a [0,100] scale (in %).

```{r 100convert, include=FALSE}
ToPlot*100
```

* You can customize the colors:

```{r rainbowColor, results="hide"}
# details:
ToPlot=ToPlot*100 # preparing labels

```



```{r barplot2, include=FALSE}
paletteHereNew=c('gray') # just one color
```



* Avoid missing values and prepare frequency table. We replaced the missing values (now they are 'Unknown'). Here, you need to transform the _table_ into a **data frame**:

```{r ggplot1, include=FALSE}
tableFreq=as.data.frame(ToPlot)
names(tableFreq)=c("locale","pct")
#you have:
tableFreq
```


* Call the library:

```{r ggplot_call, include=FALSE}
library(ggplot2)
```

* Create the base _object_, which is not a plot, just informing the main variables:

```{r ggplot_base, results="hide"}
#base GGPLOT2 starts with a "base", telling WHAT VARIABLES TO PLOT
base= ggplot(data = tableFreq, 
            aes(x = locale,
                y = pct)) 

```

* On top of the previous object, add the layer that produces the main plots (the next layers will add or customize elements in the plot):

```{r bar_gg, results="hide"}
plot1 = base + geom_bar(fill ="gray",
                        stat = 'identity') # y is just what it is!
plot1
```

* We can now pay attention to the titles:

```{r title_gg, results="hide"}
plot2 = plot1 + labs(title=titleText2,
                     x =NULL, 
                     y = NULL,
                     caption = sourceText)
plot2

```

* Add the reference lines:

```{r refl_gg, results="hide"}
plot3 = plot2 + geom_hline(yintercept = 25, #where
                           linetype="dashed", 
                           size=1.5, #thickness
                           alpha=0.5) #transparency
plot3
```

* Customize the axes:

```{r units_gg, results="hide"}
library(scales)

# customize Y axis
plot4 = plot3 + scale_y_continuous(breaks=c(0,10, 25,40,50),
                                 limits = c(0, 50), # expand = c(0, 0),
                                 labels=scales::unit_format(suffix = '%')) 
plot4
```

* Less ink and title/subtitle positions:
```{r title2_gg, results="hide"}
plot5 = plot4 + theme(panel.background = element_rect(fill = "white",
                                                    colour = "grey50"),
                    plot.caption = element_text(hjust = 0), # default was 1
                    plot.title = element_text(hjust = 0.5))
plot5
```

* annotating the bars:

```{r annot_gg, results="hide"}

plot6 = plot5 + geom_text(aes(
                            y = pct ,
                            label = paste0(round(pct,2), '%')),
                        vjust=1, # if flipping 'hjust'
                        size = 3)
# wanna flip the plot?
plot6 #+ coord_flip()

```


Bar plots are the default option for categorical variables. In general, you see the distribution of the classification, which allows you to identify **concentration**. For that reason, ordering the bars by height can be helpful:

```{r orderBars_base, eval=FALSE}
###
ToPlotOrd=sort(ToPlot)
###

par(mgp=c(1,0.5,0)) # distance label, tickText,tick
location=barplot(ToPlotOrd,
         col = paletteHereNew,
         border=NA,
         main=titleText2,
         xlim=c(0,50), 
         xlab = '(in %)',
         horiz = T,
         cex.names = 0.7,
         cex.lab=0.6,
         xaxt="n") # no x-axis, so I customize it below...

text(x=ToPlotOrd,y=location,labels=plotLabels,pos = 2,cex = 0.7) 
title(sub=sourceText, adj=0,cex.sub=0.7,line = 3) 

# reference line
abline(v=25,lty=3,lwd=3)

# customizong tick values
xtick<-c(0,10,25,40,50)
axis(side=1, at=xtick, labels = xtick,cex.axis=0.8)

```

The plot above simply change the order of the _table_. If you want to do the same with _ggplot_ you should try the command:

```{r orderFor_gg, results="hide"}
tableFreq[order(-tableFreq$pct),]
```



```{r ggplot_new, eval=TRUE}

plot7=plot6 + coord_flip() + aes(x=reorder(locale, pct))

plot7


```


